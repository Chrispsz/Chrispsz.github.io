<!DOCTYPE html>
<html lang="pt-br">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>IPTV Manager - Auto Cache & Multi-Account</title>
  
  <!-- React & ReactDOM -->
  <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
  
  <!-- Babel -->
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  
  <!-- Tailwind CSS -->
  <script src="https://cdn.tailwindcss.com"></script>
  
  <!-- HLS.js -->
  <script src="https://cdn.jsdelivr.net/npm/hls.js@latest"></script>

  <style>
    body { background-color: #09090b; color: white; }
    ::-webkit-scrollbar { width: 8px; }
    ::-webkit-scrollbar-track { background: #18181b; }
    ::-webkit-scrollbar-thumb { background: #3f3f46; border-radius: 4px; }
    ::-webkit-scrollbar-thumb:hover { background: #52525b; }
  </style>
</head>
<body>
  <div id="root"></div>

  <script type="text/babel">
    const { useState, useEffect, useCallback, useRef } = React;
    const { createRoot } = ReactDOM;

    // ============================================
    // CONFIGURA√á√ïES E PROXIES
    // ============================================
    const CORS_PROXIES = [
      '', 
      'https://corsproxy.io/?',
      'https://api.allorigins.win/raw?url=',
    ];

    const CACHE_DURATION_MS = 30 * 60 * 1000; // 30 minutos

    const PRIORITY_CONFIG = {
      'PREMIERE': 1,
      'AMAZON PRIME': 2,
      'ESPN': 3,
      'SPORTV': 4
    };

    const KEYWORDS = [
      'PREMIERE', 'PREMIERE FC', 'PREMIERE CLUBES',
      'AMAZON PRIME', 'PRIME VIDEO', 'AMAZON',
      'ESPN', 'ESPN 2', 'ESPN 3', 'ESPN BRASIL', 'ESPN4',
      'SPORTV', 'SPOR TV', 'SPORTV 2', 'SPORTV 3'
    ];

    // ============================================
    // FETCH COM PROXY
    // ============================================
    async function fetchWithProxy(url, timeout = 10000) {
      for (const proxy of CORS_PROXIES) {
        try {
          const controller = new AbortController();
          const timeoutId = setTimeout(() => controller.abort(), timeout);
          
          const finalUrl = proxy ? `${proxy}${encodeURIComponent(url)}` : url;
          const res = await fetch(finalUrl, { signal: controller.signal });
          clearTimeout(timeoutId);
          
          if (res.ok) return res;
        } catch {
          continue;
        }
      }
      throw new Error('Falha em todos os proxies');
    }

    // ============================================
    // COMPONENTE PRINCIPAL
    // ============================================
    function App() {
      const [accounts, setAccounts] = useState([]);
      const [channels, setChannels] = useState([]);
      const [kvConfig, setKvConfig] = useState({ token: '', accountId: '', namespaceId: '' });
      const [importText, setImportText] = useState('');
      const [loading, setLoading] = useState(false);
      const [loadingMessage, setLoadingMessage] = useState('');
      const [lastUpdated, setLastUpdated] = useState(null);
      const [searchTerm, setSearchTerm] = useState('');
      const [playerUrl, setPlayerUrl] = useState('');
      const [playerTitle, setPlayerTitle] = useState('');
      const [notification, setNotification] = useState('');
      const [activeTab, setActiveTab] = useState('channels');
      const [showKvConfig, setShowKvConfig] = useState(false);

      // ============================================
      // L√ìGICA DE CACHE E LIMPEZA
      // ============================================
      const clearChannelsCache = useCallback(() => {
        setChannels([]);
        setLastUpdated(null);
        localStorage.removeItem('iptv_channels_cache');
        console.log('üóëÔ∏è Cache de canais limpo.');
      }, []);

      useEffect(() => {
        const savedAccounts = localStorage.getItem('iptv_accounts');
        if (savedAccounts) setAccounts(JSON.parse(savedAccounts));
        
        const savedKv = localStorage.getItem('iptv_kv');
        if (savedKv) setKvConfig(JSON.parse(savedKv));

        const cachedRaw = localStorage.getItem('iptv_channels_cache');
        if (cachedRaw) {
          try {
            const cached = JSON.parse(cachedRaw);
            // Valida cache contra contas atuais
            const validCacheChannels = cached.channels.filter(ch => accounts.some(a => a.id === ch.accountId));
            setChannels(validCacheChannels.length !== cached.channels.length ? validCacheChannels : cached.channels);
            setLastUpdated(cached.timestamp);
          } catch (e) { console.error('Erro ao ler cache', e); }
        }
      }, []);

      useEffect(() => { localStorage.setItem('iptv_accounts', JSON.stringify(accounts)); }, [accounts]);
      useEffect(() => { localStorage.setItem('iptv_kv', JSON.stringify(kvConfig)); }, [kvConfig]);
      useEffect(() => { 
        if (channels.length > 0) {
          localStorage.setItem('iptv_channels_cache', JSON.stringify({ channels, timestamp: Date.now() }));
        }
      }, [channels]);

      const notify = useCallback((msg) => {
        setNotification(msg);
        setTimeout(() => setNotification(''), 4000);
      }, []);

      const parseAccountUrl = (url) => {
        const match = url.match(/https?:\/\/([^:]+):([^@]+)@([^:\/]+):?(\d+)?/);
        if (!match) return null;
        return { user: match[1], pass: match[2], host: match[3], port: match[4] || '80' };
      };

      // ============================================
      // FUN√á√ïES DE GERENCIAMENTO
      // ============================================
      const smartParse = () => {
        if (!importText.trim()) return notify('‚ö†Ô∏è Cole os logs primeiro');
        
        const regex = /(https?:\/\/[^\/\s:]+)(?::(\d+))?\/get\.php\?username=([^&\s]+)&password=([^&\s]+)/gi;
        let match, found = 0;
        const newAccounts = [...accounts];

        while ((match = regex.exec(importText)) !== null) {
          const protocol = match[0].split('://')[0] + '://';
          const host = match[1].replace(/https?:\/\//, '');
          const port = match[2] || '80';
          const user = match[3];
          const pass = match[4];
          const finalUrl = `${protocol}${user}:${pass}@${host}:${port}`;
          
          if (!newAccounts.find(a => a.url === finalUrl)) {
            const id = `${host}-${user}-${Date.now()}`;
            newAccounts.push({ id, name: `${host.split('.')[0]}-${user.slice(0, 6)}`, url: finalUrl, status: 'unknown' });
            found++;
          }
        }

        if (found > 0) {
          setAccounts(newAccounts);
          setImportText('');
          notify(`‚úÖ ${found} conta(s) importada(s)`);
          clearChannelsCache(); // LIMPEZA AUTOM√ÅTICA
        } else {
          notify('‚ö†Ô∏è Nenhum acesso v√°lido encontrado');
        }
      };

      const removeAccount = (id) => {
        clearChannelsCache(); // LIMPEZA AUTOM√ÅTICA
        setAccounts(accounts.filter(a => a.id !== id));
        notify('‚úÖ Conta removida e cache limpo');
      };

      const handleManualClearCache = () => {
        clearChannelsCache();
        notify('üóëÔ∏è Cache limpo manualmente');
      };

      // ============================================
      // CARREGAMENTO DE CANAIS
      // ============================================
      const loadChannels = async () => {
        if (accounts.length === 0) return notify('‚ö†Ô∏è Adicione contas primeiro');

        setLoading(true);
        setLoadingMessage('Iniciando...');
        const allChannels = [];
        let successCount = 0;

        for (let i = 0; i < accounts.length; i++) {
          const account = accounts[i];
          setLoadingMessage(`Conta ${i + 1}/${accounts.length}: ${account.name}`);
          const parsed = parseAccountUrl(account.url);
          if (!parsed) {
            setAccounts(prev => prev.map(a => a.id === account.id ? { ...a, status: 'offline' } : a));
            continue;
          }

          const { user, pass, host, port } = parsed;
          const baseUrl = `http://${host}:${port}`;

          try {
            setLoadingMessage(`${account.name}: Autenticando...`);
            const authRes = await fetchWithProxy(`${baseUrl}/player_api.php?username=${user}&password=${pass}`);
            const authData = await authRes.json();
            
            if (!authData.user_info?.auth) {
              setAccounts(prev => prev.map(a => a.id === account.id ? { ...a, status: 'offline' } : a));
              continue;
            }

            const active = authData.user_info?.active_cons || 0;
            const max = authData.user_info?.max_connections || 1;
            setAccounts(prev => prev.map(a => a.id === account.id ? { ...a, status: 'online', connections: `${active}/${max}` } : a));

            setLoadingMessage(`${account.name}: Carregando canais...`);
            const channelsRes = await fetchWithProxy(`${baseUrl}/player_api.php?username=${user}&password=${pass}&action=get_live_streams`);
            const channelsData = await channelsRes.json();
            
            if (!Array.isArray(channelsData)) continue;

            for (const ch of channelsData) {
              const upper = ch.name.toUpperCase();
              const isTarget = KEYWORDS.some(kw => upper.includes(kw));
              if (!isTarget) continue;

              const serverUrl = authData.server_info?.url || `http://${host}`;
              const serverPort = authData.server_info?.port || port;
              const streamUrl = `${serverUrl}:${serverPort}/live/${user}/${pass}/${ch.stream_id}.m3u8`;
              
              let category = 'OUTROS';
              if (upper.includes('PREMIERE')) category = 'PREMIERE';
              else if (upper.includes('AMAZON') || upper.includes('PRIME')) category = 'AMAZON PRIME';
              else if (upper.includes('ESPN')) category = 'ESPN';
              else if (upper.includes('SPORTV') || upper.includes('SPOR TV')) category = 'SPORTV';

              const channelId = `${account.id}-${ch.stream_id}`; // ID Composto para m√∫ltiplos acessos
              
              if (!allChannels.find(c => c.id === channelId)) {
                allChannels.push({ 
                  id: channelId,
                  name: ch.name, 
                  url: streamUrl, 
                  account: account.name,
                  accountId: account.id,
                  category
                });
              }
            }
            successCount++;
          } catch (error) {
            console.error(`Erro na conta ${account.name}:`, error);
            setAccounts(prev => prev.map(a => a.id === account.id ? { ...a, status: 'offline' } : a));
          }
        }

        allChannels.sort((a, b) => {
          const pA = PRIORITY_CONFIG[a.category] || 99;
          const pB = PRIORITY_CONFIG[b.category] || 99;
          if (pA !== pB) return pA - pB;
          return a.name.localeCompare(b.name);
        });

        setChannels(allChannels);
        setLastUpdated(Date.now());
        setLoading(false);
        setLoadingMessage('');
        
        if (allChannels.length > 0) {
          notify(`‚úÖ ${allChannels.length} canais de ${successCount} conta(s)`);
          setActiveTab('channels');
        } else {
          notify('‚ö†Ô∏è Nenhum canal encontrado.');
        }
      };

      // ============================================
      // SYNC & EXPORT
      // ============================================
      const updateKV = async () => {
        if (!kvConfig.token || !kvConfig.accountId || !kvConfig.namespaceId) return notify('‚ö†Ô∏è Configure as credenciais do KV');
        if (channels.length === 0) return notify('‚ö†Ô∏è Carregue os canais primeiro');

        setLoading(true);
        setLoadingMessage('Atualizando Cloudflare KV...');

        try {
          const streamsByCategory = {};
          for (const ch of channels) {
            const cat = ch.category.toLowerCase().replace(' ', '_');
            if (!streamsByCategory[cat]) streamsByCategory[cat] = [];
            streamsByCategory[cat].push({
              name: ch.name,
              title: ch.epgTitle || '',
              url: ch.url,
              behaviorHints: { notWebReady: true }
            });
          }

          const payload = {
            version: '2.0.0',
            updatedAt: new Date().toISOString(),
            totalChannels: channels.length,
            categories: Object.keys(streamsByCategory),
            streams: streamsByCategory
          };

          const kvUrl = `https://api.cloudflare.com/client/v4/accounts/${kvConfig.accountId}/storage/kv/namespaces/${kvConfig.namespaceId}/values/iptv_streams`;
          const res = await fetch(kvUrl, {
            method: 'PUT',
            headers: { 'Authorization': `Bearer ${kvConfig.token}`, 'Content-Type': 'application/json' },
            body: JSON.stringify(payload)
          });

          if (res.ok) notify('‚úÖ KV atualizado!');
          else notify(`‚ùå Erro: ${(await res.text()).slice(0, 100)}`);
        } catch (error) { notify(`‚ùå Erro: ${error.message}`); }
        setLoading(false);
        setLoadingMessage('');
      };

      const exportM3U = () => {
        if (channels.length === 0) return notify('‚ö†Ô∏è Carregue os canais primeiro');
        let m3u = '#EXTM3U\n';
        for (const ch of channels) m3u += `#EXTINF:-1 group-title="${ch.category}",${ch.name}\n${ch.url}\n`;
        const blob = new Blob([m3u], { type: 'audio/x-mpegurl' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `canais-${new Date().toISOString().split('T')[0]}.m3u`;
        a.click();
        URL.revokeObjectURL(url);
        notify('‚úÖ Arquivo M3U baixado');
      };

      const copyUrl = (url) => {
        navigator.clipboard.writeText(url);
        notify('‚úÖ URL copiada!');
      };

      const castToTV = (url, title) => {
        const wvcUrl = `https://nicoapps.com/wvc/?video=${encodeURIComponent(url)}&title=${encodeURIComponent(title)}`;
        window.open(wvcUrl, '_blank');
      };

      const filteredChannels = channels.filter(ch => {
        if (!searchTerm) return true;
        const term = searchTerm.toLowerCase();
        return ch.name.toLowerCase().includes(term) || ch.category.toLowerCase().includes(term);
      });

      const groupedChannels = filteredChannels.reduce((acc, ch) => {
        if (!acc[ch.category]) acc[ch.category] = [];
        acc[ch.category].push(ch);
        return acc;
      }, {});

      const categoryOrder = ['PREMIERE', 'AMAZON PRIME', 'ESPN', 'SPORTV', 'OUTROS'];
      const sortedCategories = Object.keys(groupedChannels).sort((a, b) => categoryOrder.indexOf(a) - categoryOrder.indexOf(b));

      const timeAgo = lastUpdated ? Math.floor((Date.now() - lastUpdated) / 60000) : null;
      const cacheStale = lastUpdated ? (Date.now() - lastUpdated) > CACHE_DURATION_MS : false;

      return (
        <div className="min-h-screen bg-zinc-950 text-white">
          {notification && (
            <div className="fixed top-4 left-1/2 -translate-x-1/2 bg-zinc-800 border border-zinc-700 rounded-lg px-6 py-3 shadow-xl z-50">
              {notification}
            </div>
          )}

          {loading && (
            <div className="fixed inset-0 bg-black/80 flex items-center justify-center z-50">
              <div className="bg-zinc-900 border border-zinc-800 rounded-lg p-8 text-center">
                <div className="w-12 h-12 border-4 border-purple-500 border-t-transparent rounded-full animate-spin mx-auto mb-4"></div>
                <p className="text-zinc-400">{loadingMessage || 'Carregando...'}</p>
              </div>
            </div>
          )}

          {playerUrl && (
            <PlayerModal 
              url={playerUrl} 
              title={playerTitle} 
              onClose={() => { setPlayerUrl(''); setPlayerTitle(''); }}
              onCast={() => castToTV(playerUrl, playerTitle)}
              onCopy={() => copyUrl(playerUrl)}
            />
          )}

          <header className="bg-zinc-900 border-b border-zinc-800 sticky top-0 z-40">
            <div className="max-w-6xl mx-auto px-4 py-3">
              <div className="flex items-center justify-between gap-4">
                <div>
                  <h1 className="text-xl font-bold text-purple-400">üì∫ IPTV Manager v3</h1>
                  {timeAgo !== null && (
                    <p className={`text-xs ${cacheStale ? 'text-yellow-500' : 'text-zinc-500'}`}>
                      Atualizado h√° {timeAgo} min {cacheStale && '(antigo)'}
                    </p>
                  )}
                </div>
                <div className="flex gap-2">
                  <button onClick={() => setActiveTab('channels')} className={`px-4 py-2 rounded text-sm font-medium transition ${activeTab === 'channels' ? 'bg-purple-600' : 'bg-zinc-800 hover:bg-zinc-700'}`}>
                    üì∫ Canais {channels.length > 0 && `(${channels.length})`}
                  </button>
                  <button onClick={() => setActiveTab('config')} className={`px-4 py-2 rounded text-sm font-medium transition ${activeTab === 'config' ? 'bg-purple-600' : 'bg-zinc-800 hover:bg-zinc-700'}`}>
                    ‚öôÔ∏è Config
                  </button>
                </div>
              </div>
            </div>
          </header>

          <main className="max-w-6xl mx-auto px-4 py-6">
            {activeTab === 'config' ? (
              <div className="space-y-6">
                {/* Importar */}
                <div className="bg-zinc-900 border border-zinc-800 rounded-lg p-6">
                  <h2 className="text-lg font-bold mb-4">üì• Importar Acessos</h2>
                  <textarea value={importText} onChange={(e) => setImportText(e.target.value)} rows={4} placeholder="Cole os logs aqui..." className="w-full bg-black border border-zinc-700 rounded px-3 py-2 text-sm font-mono mb-4 placeholder:text-zinc-600" />
                  <button onClick={smartParse} className="bg-purple-600 hover:bg-purple-700 px-6 py-2 rounded font-medium transition">üîç Extrair Acessos</button>
                </div>

                {/* Contas */}
                <div className="bg-zinc-900 border border-zinc-800 rounded-lg p-6">
                  <div className="flex items-center justify-between mb-4">
                    <h2 className="text-lg font-bold">üë§ Contas ({accounts.length})</h2>
                    <button onClick={loadChannels} disabled={loading || accounts.length === 0} className="bg-green-600 hover:bg-green-700 disabled:bg-zinc-700 disabled:cursor-not-allowed px-6 py-2 rounded font-medium transition">üîÑ Carregar Canais</button>
                  </div>

                  {accounts.length === 0 ? (
                    <p className="text-zinc-500 text-center py-8">Nenhuma conta adicionada</p>
                  ) : (
                    <div className="space-y-2">
                      {accounts.map(acc => {
                        const parsed = parseAccountUrl(acc.url);
                        const statusColors = { 'online': 'bg-green-500', 'offline': 'bg-red-500', 'checking': 'bg-yellow-500', 'unknown': 'bg-zinc-500' };
                        return (
                          <div key={acc.id} className="bg-black border border-zinc-800 rounded-lg p-3 flex items-center justify-between gap-4">
                            <div className="flex items-center gap-3 min-w-0">
                              <div className={`w-2.5 h-2.5 rounded-full ${statusColors[acc.status]}`}></div>
                              <div className="min-w-0">
                                <p className="font-medium truncate">{acc.name}</p>
                                <p className="text-xs text-zinc-500 truncate">{parsed?.host || 'URL inv√°lida'}</p>
                              </div>
                            </div>
                            <div className="flex items-center gap-3">
                              {acc.connections && <span className="text-xs text-zinc-400">{acc.connections}</span>}
                              <button onClick={() => removeAccount(acc.id)} className="text-red-400 hover:text-red-300 text-sm">‚úï</button>
                            </div>
                          </div>
                        );
                      })}
                    </div>
                  )}
                </div>

                {/* Ferramentas & Cache */}
                <div className="bg-zinc-900 border border-zinc-800 rounded-lg p-6">
                  <div className="flex items-center justify-between mb-4">
                    <h2 className="text-lg font-bold">üõ†Ô∏è Ferramentas & Dados</h2>
                    <button onClick={() => setShowKvConfig(!showKvConfig)} className="bg-orange-600 hover:bg-orange-700 px-4 py-2 rounded font-medium transition">‚òÅÔ∏è Cloudflare KV</button>
                  </div>

                  {/* Se√ß√£o de Cache */}
                  <div className="mb-6 p-4 bg-black/50 border border-zinc-800 rounded-lg flex items-center justify-between">
                    <div>
                      <h3 className="font-medium text-sm">üóëÔ∏è Cache de Canais</h3>
                      <p className="text-xs text-zinc-500">Limpa a lista carregada na mem√≥ria e no navegador.</p>
                    </div>
                    <button onClick={handleManualClearCache} className="bg-red-900/50 hover:bg-red-600 text-red-300 hover:text-white px-4 py-2 rounded text-sm transition">Limpar Agora</button>
                  </div>

                  {/* Bot√£o Exportar */}
                  <button onClick={exportM3U} disabled={channels.length === 0} className="bg-blue-600 hover:bg-blue-700 disabled:bg-zinc-700 disabled:cursor-not-allowed px-6 py-2 rounded font-medium transition">üìÑ Baixar M3U</button>

                  {/* Config KV */}
                  {showKvConfig && (
                    <div className="mt-4 p-4 bg-black border border-zinc-800 rounded-lg space-y-3">
                      <p className="text-xs text-zinc-400 mb-2">Sincronizar com Stremio</p>
                      <input type="password" placeholder="API Token" value={kvConfig.token} onChange={(e) => setKvConfig({ ...kvConfig, token: e.target.value })} className="w-full bg-zinc-900 border border-zinc-700 rounded px-3 py-2 text-sm" />
                      <input type="text" placeholder="Account ID" value={kvConfig.accountId} onChange={(e) => setKvConfig({ ...kvConfig, accountId: e.target.value })} className="w-full bg-zinc-900 border border-zinc-700 rounded px-3 py-2 text-sm" />
                      <input type="text" placeholder="Namespace ID" value={kvConfig.namespaceId} onChange={(e) => setKvConfig({ ...kvConfig, namespaceId: e.target.value })} className="w-full bg-zinc-900 border border-zinc-700 rounded px-3 py-2 text-sm" />
                      <button onClick={updateKV} disabled={loading || channels.length === 0} className="w-full bg-orange-600 hover:bg-orange-700 disabled:bg-zinc-700 px-4 py-2 rounded font-medium transition">‚¨ÜÔ∏è Enviar para KV</button>
                    </div>
                  )}
                </div>
              </div>
            ) : (
              <div className="space-y-6">
                {channels.length > 0 && (
                  <div className="sticky top-16 z-30 bg-zinc-950 py-2">
                    <input type="text" placeholder="üîç Buscar..." value={searchTerm} onChange={(e) => setSearchTerm(e.target.value)} className="w-full bg-zinc-900 border border-zinc-800 rounded-lg px-4 py-3 focus:border-purple-500 outline-none transition" />
                  </div>
                )}

                {channels.length === 0 ? (
                  <div className="text-center py-16">
                    <p className="text-zinc-500 mb-4">Nenhum canal carregado</p>
                    <button onClick={() => setActiveTab('config')} className="bg-purple-600 hover:bg-purple-700 px-6 py-2 rounded font-medium transition">‚öôÔ∏è Ir para Configura√ß√µes</button>
                  </div>
                ) : filteredChannels.length === 0 ? (
                  <p className="text-center text-zinc-500 py-8">Nenhum canal encontrado</p>
                ) : (
                  <div className="space-y-8">
                    {sortedCategories.map(category => (
                      <div key={category}>
                        <h2 className="text-lg font-bold mb-3 text-zinc-300">
                          {category === 'PREMIERE' && '‚öΩ '}
                          {category === 'AMAZON PRIME' && 'üîµ '}
                          {category === 'ESPN' && 'üèÜ '}
                          {category === 'SPORTV' && 'üì∫ '}
                          {category} ({groupedChannels[category].length})
                        </h2>
                        <div className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-3">
                          {groupedChannels[category].map(ch => (
                            <ChannelCard key={ch.id} channel={ch} onPlay={() => { setPlayerUrl(ch.url); setPlayerTitle(ch.name); }} onCast={() => castToTV(ch.url, ch.name)} onCopy={() => copyUrl(ch.url)} />
                          ))}
                        </div>
                      </div>
                    ))}
                  </div>
                )}
              </div>
            )}
          </main>
        </div>
      );
    }

    // ============================================
    // COMPONENTES FILHOS
    // ============================================
    function ChannelCard({ channel, onPlay, onCast, onCopy }) {
      const categoryColors = {
        'PREMIERE': 'border-l-green-500',
        'AMAZON PRIME': 'border-l-blue-500',
        'ESPN': 'border-l-red-500',
        'SPORTV': 'border-l-purple-500',
        'OUTROS': 'border-l-zinc-500'
      };

      return (
        <div className={`bg-zinc-900 border border-zinc-800 border-l-4 ${categoryColors[channel.category] || categoryColors.OUTROS} rounded-lg p-4`}>
          <p className="font-medium mb-1 truncate" title={channel.name}>{channel.name}</p>
          <p className="text-xs text-zinc-500 mb-3">{channel.account}</p>
          
          <div className="flex gap-2">
            <button onClick={onPlay} className="flex-1 bg-zinc-800 hover:bg-zinc-700 py-2 rounded text-sm font-medium transition">‚ñ∂ Play</button>
            <button onClick={onCast} className="bg-purple-600 hover:bg-purple-700 px-3 py-2 rounded text-sm transition" title="Enviar para TV">üì∫</button>
            <button onClick={onCopy} className="bg-zinc-800 hover:bg-zinc-700 px-3 py-2 rounded text-sm transition" title="Copiar URL">üìã</button>
          </div>
        </div>
      );
    }

    function PlayerModal({ url, title, onClose, onCast, onCopy }) {
      const videoRef = useRef(null);
      const hlsRef = useRef(null);
      const [error, setError] = useState('');
      const [loading, setLoading] = useState(true);

      useEffect(() => {
        const video = videoRef.current;
        if (!video) return;

        const handleKeyDown = (e) => { if (e.key === 'Escape') onClose(); };
        window.addEventListener('keydown', handleKeyDown);

        if (Hls.isSupported()) {
          const hls = new Hls({
            enableWorker: true, lowLatencyMode: false, maxBufferLength: 30, maxMaxBufferLength: 60,
            maxBufferSize: 60 * 1000 * 1000, maxBufferHole: 0.5,
            fragLoadingTimeOut: 20000, manifestLoadingTimeOut: 15000, levelLoadingTimeOut: 15000,
          });
          
          hlsRef.current = hls;
          hls.loadSource(url);
          hls.attachMedia(video);

          hls.on(Hls.Events.MANIFEST_PARSED, () => {
            setLoading(false);
            video.play().catch(() => {});
          });

          hls.on(Hls.Events.ERROR, (_, data) => {
            if (data.fatal) {
              setLoading(false);
              if (data.type === Hls.ErrorTypes.NETWORK_ERROR) setError('Erro de rede.');
              else if (data.type === Hls.ErrorTypes.MEDIA_ERROR) hls.recoverMediaError();
              else setError('Erro ao reproduzir.');
            }
          });

          return () => {
            hls.destroy();
            window.removeEventListener('keydown', handleKeyDown);
          };
        } else if (video.canPlayType('application/vnd.apple.mpegurl')) {
          video.src = url;
          video.addEventListener('loadedmetadata', () => setLoading(false));
          video.addEventListener('error', () => setError('Erro ao carregar'));
          return () => window.removeEventListener('keydown', handleKeyDown);
        } else {
          setError('Navegador n√£o suporta HLS');
          setLoading(false);
          return () => window.removeEventListener('keydown', handleKeyDown);
        }
      }, [url, onClose]);

      return (
        <div className="fixed inset-0 bg-black z-50 flex flex-col">
          <div className="flex items-center justify-between p-4 bg-zinc-900">
            <h3 className="font-medium truncate pr-4">{title}</h3>
            <div className="flex items-center gap-2">
              <button onClick={onCopy} className="bg-zinc-800 hover:bg-zinc-700 px-3 py-1.5 rounded text-sm transition">üìã Copiar URL</button>
              <button onClick={onCast} className="bg-purple-600 hover:bg-purple-700 px-3 py-1.5 rounded text-sm transition">üì∫ Enviar TV</button>
              <button onClick={onClose} className="bg-red-600 hover:bg-red-700 px-4 py-1.5 rounded text-sm transition">‚úï Fechar</button>
            </div>
          </div>

          <div className="flex-1 flex items-center justify-center bg-black relative">
            {loading && !error && (
              <div className="absolute inset-0 flex items-center justify-center">
                <div className="w-12 h-12 border-4 border-purple-500 border-t-transparent rounded-full animate-spin"></div>
              </div>
            )}
            
            {error ? (
              <div className="text-center p-8">
                <p className="text-red-400 mb-4">‚ùå {error}</p>
                <div className="flex justify-center gap-3">
                  <button onClick={onCopy} className="bg-zinc-800 hover:bg-zinc-700 px-4 py-2 rounded transition">üìã Copiar URL</button>
                  <button onClick={onCast} className="bg-purple-600 hover:bg-purple-700 px-4 py-2 rounded transition">üì∫ Enviar para TV</button>
                </div>
                <p className="text-xs text-zinc-500 mt-4">Use em VLC ou outro player.</p>
              </div>
            ) : (
              <video ref={videoRef} controls autoPlay playsInline className="w-full h-full" />
            )}
          </div>
        </div>
      );
    }

    // Renderiza√ß√£o
    const root = createRoot(document.getElementById('root'));
    root.render(<App />);
  </script>
</body>
</html>
